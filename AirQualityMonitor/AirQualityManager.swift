//
//  Model.swift
//  AirQualityMonitor
//
//  Created by Giulio on 14/11/22.
//

import CoreLocation
import Foundation


class AirQualityManager: ObservableObject {

    //Publish Response values
    @Published var aqiDisplay = ""
    @Published var aqiColor = ""
    @Published var aqiCategory = ""
    @Published var aqiRecommendations = ""
    @Published var aqiPollutant = ""

    @Published var aqiValueInt = 0
    @Published var aqiValue = 0.00
    @Published var aqiValueMapped = 0.1
    
    @Published var pm25Value = 0.0
    @Published var pm10Value = 0.0


    // HTTP request to get the current weather depending on the coordinates we got from LocationManager
    func getAirQuality(latitude: CLLocationDegrees, longitude: CLLocationDegrees) async throws -> Response {
        // Replace YOUR_API_KEY in the link below with your own
        
        let APIKey = "d5d82db6dcd4489f8a411a21b57b0303"
        
        guard let url = URL(string:
            "https://api.breezometer.com/air-quality/v2/current-conditions?lat=\(latitude)&lon=\(longitude)&key=\(APIKey)&features=breezometer_aqi,health_recommendations,pollutants_concentrations")
                
                
        else { fatalError("Missing URL") }

        let urlRequest = URLRequest(url: url)

        let (data, response) = try await URLSession.shared.data(for: urlRequest)
        guard (response as? HTTPURLResponse)?.statusCode == 200 else { fatalError("Error while fetching data") }
        let decodedData = try JSONDecoder().decode(Response.self, from: data)

        let range1_min = 1.00
        let range1_max = 100.00

        let range2_min = 0.30
        let range2_max = 0.89
        
        DispatchQueue.main.async {
        //publish values (how should it be done properly?)
            self.aqiDisplay = decodedData.data.indexes.baqi.aqiDisplay
            self.aqiColor = decodedData.data.indexes.baqi.color
            self.aqiCategory = decodedData.data.indexes.baqi.category
            self.aqiRecommendations = decodedData.data.healthRecommendations.general_population
            self.aqiPollutant = decodedData.data.indexes.baqi.dominantPollutant
        

            self.aqiValueInt = decodedData.data.indexes.baqi.aqi
            self.aqiValue = Double(self.aqiValueInt)
            
            self.aqiValueMapped = (self.aqiValue - range1_min) * (range2_max - range2_min) / (range1_max - range1_min) + range2_min

            self.pm25Value = decodedData.data.pollutants.pm25.concentration.value
            self.pm10Value = decodedData.data.pollutants.pm10.concentration.value
            
        }
        //need to tidy this up? make a function?

        print("PM: \(decodedData.data.pollutants.pm10.concentration.value)")
        
        return decodedData

        }


}




//Model of the API response

struct Response: Codable {

    let data: apiData

}


struct apiData: Codable {

    let datetime: String
    let dataAvailable: Bool
    let indexes: Indexes
    let healthRecommendations: HealthRecommendations
    let pollutants: Pollutants

    private enum CodingKeys: String, CodingKey {

        case datetime
        case dateAvailable = "data_available"
        case indexes
        case healthRecommendations = "health_recommendations"
        case pollutants = "pollutants"


    }

    //this is needed when using coding keys because the init generated by swift will not work anywmore?
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(datetime, forKey: .datetime)
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        datetime = try container.decode(String.self, forKey: .datetime)

        dataAvailable = try container.decode(Bool.self, forKey: .dateAvailable)

        indexes = try container.decode(Indexes.self, forKey: .indexes)

        healthRecommendations = try container.decode(HealthRecommendations.self, forKey: .healthRecommendations)
        
        pollutants = try container.decode(Pollutants.self, forKey: .pollutants)


    }

}

struct Indexes: Codable {
    let baqi: Baqi

}

struct HealthRecommendations: Codable {
    let general_population: String
//    let elderly: String
//    let lung_diseases: String
//    let heart_diseases: String
//    let active: String
//    let pregrant_women: String
//    let children: String
}


struct Pollutants: Codable {
    let pm10: Pm10
    let pm25: Pm25

}

struct Pm10: Codable {
    
    let display_name: String
    let full_name: String
    let concentration: Concentration
    
}

struct Pm25: Codable {
    
    let display_name: String
    let full_name: String
    let concentration: Concentration
    
}

struct Concentration: Codable {
    let value: Double
    let units: String
}

    




struct Baqi: Codable {
    let displayName: String
    let aqi: Int
    let aqiDisplay: String
    let color: String
    let category: String
    let dominantPollutant: String

    private enum CodingKeys: String, CodingKey {
      case displayName = "display_name"
      case aqi
      case aqiDisplay = "aqi_display"
      case color
      case category
      case dominantPollutant = "dominant_pollutant"
    }



}










