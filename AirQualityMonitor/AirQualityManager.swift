//
//  Model.swift
//  AirQualityMonitor
//
//  Created by Giulio on 14/11/22.
//

import CoreLocation
import Foundation


class AirQualityManager: ObservableObject {
    // HTTP request to get the current weather depending on the coordinates we got from LocationManager
    func getAirQuality(latitude: CLLocationDegrees, longitude: CLLocationDegrees) async throws -> Response {
        // Replace YOUR_API_KEY in the link below with your own
        guard let url = URL(string:
            "https://api.breezometer.com/air-quality/v2/current-conditions?lat=\(latitude)&lon=\(longitude)&key=65bc6c1ee49648b8acc79ceeddc4130a")
        
        else { fatalError("Missing URL") }

        let urlRequest = URLRequest(url: url)
        
        
        print(urlRequest)
        
        let (data, response) = try await URLSession.shared.data(for: urlRequest)
        
        guard (response as? HTTPURLResponse)?.statusCode == 200 else { fatalError("Error while fetching data") }
        
        let decodedData = try JSONDecoder().decode(Response.self, from: data)
        
        
        print("AQI Value: \(decodedData.data.indexes.baqi.aqiDisplay)")
        
        return decodedData
    }
}




//Model of the API response

struct Response: Codable {
    
    let data: apiData

}


struct apiData: Codable {
    
    let datetime: String
    let dataAvailable: Bool
    let indexes: Indexes

    private enum CodingKeys: String, CodingKey {

        case datetime
        case dateAvailable = "data_available"
        case indexes

    }
    
    //this is needed when using coding keys because the init generated by swift will not work anywmore?
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(datetime, forKey: .datetime)
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        datetime = try container.decode(String.self, forKey: .datetime)
        
        dataAvailable = try container.decode(Bool.self, forKey: .dateAvailable)
        
        indexes = try container.decode(Indexes.self, forKey: .indexes)

    }
    
}

struct Indexes: Codable {
    let baqi: Baqi
    

}


struct Baqi: Codable {
    let displayName: String
    let aqi: Int
    let aqiDisplay: String
    let color: String
    let category: String
    let dominantPollutant: String
    
    private enum CodingKeys: String, CodingKey {
      case displayName = "display_name"
      case aqi
      case aqiDisplay = "aqi_display"
      case color
      case category
      case dominantPollutant = "dominant_pollutant"
    }
    
    
    
}





//
//import Foundation
//
//struct Unknown: Codable {
//  let metadata: Any?
//  let data: Data
//  let error: Any?
//}
//
//struct Data: Codable {
//  let datetime: Date
//  let dataAvailable: Bool
//  let indexes: Index
//
//  private enum CodingKeys: String, CodingKey {
//    case datetime
//    case dataAvailable = "data_available"
//    case indexes
//  }
//}
//
//struct Index: Codable {
//  let baqi: Baqi
//}
//
//struct Baqi: Codable {
//  let displayName: String
//  let aqi: Int
//  let aqiDisplay: String
//  let color: String
//  let category: String
//  let dominantPollutant: String
//
//  private enum CodingKeys: String, CodingKey {
//    case displayName = "display_name"
//    case aqi
//    case aqiDisplay = "aqi_display"
//    case color
//    case category
//    case dominantPollutant = "dominant_pollutant"
//  }
//}
//
